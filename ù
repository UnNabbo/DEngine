#include <cmath>
#include <stdlib.h>
#include <vcruntime_string.h>
#include <windows.h>

#include <wingdi.h>
#include <winnt.h>
#include <winuser.h>

#include "dmath.h"

#include "defines.h"

bool running = true;


struct Bitmap{
    BITMAPINFO Info;
    int32 Height, Width;
    void * Memory;
};

global Bitmap Backbuffer;


ivec2 GetWindowSize(HWND Window) {
    RECT ClientRect;
    GetClientRect(Window, &ClientRect);
    int Width = ClientRect.right - ClientRect.left; 
    int Height = ClientRect.bottom - ClientRect.top;
    return {Width, Height};
}


void SetPixel(Bitmap * Buffer,int32 x, int32 y, uint8 r = 0xff, uint8 g = 0xff, uint8 b = 0xff){
    *(((uint32*)Buffer->Memory) + Buffer->Width * y + x ) = b | g << 8 | r << 16;
}

void DrawLine(Bitmap* Buffer, int x1, int y1, int x2, int y2){
    int DeltaX = abs(x2 - x1);
    int SingX = (x1 < x2) ? 1 : -1;
    int DeltaY = -abs(y2 - y1);
    int SingY = (y1 < y2) ? 1 : -1;
    int Error =  DeltaX + DeltaY;

    int X = x1;
    int Y = y1;
    while(true){
        SetPixel(Buffer, X, Y);
        if(X == x2 && Y == y2) break;
        int Error2 = Error * 2;
        if(Error2 >= DeltaY){
            if(X == x2) break;
            Error += DeltaY;
            X += SingX;
        }

        if(Error2 <= DeltaX){
            if(Y == y2) break;
            Error += DeltaX;
            Y += SingY;
        }
    }
}

void DrawVLine(Bitmap* Buffer,int X, int y1, int y2){
    int SingY = (y1 < y2) ? 1 : -1;
    int DeltaY = -abs(y2 - y1);
    int Y = y1;
    while(true){
        SetPixel(Buffer, X, Y);
        if(Y == y2) break;
        Y += SingY;
    }
}


void DrawHLine(Bitmap* Buffer,int Y, int x1, int x2){
    
    uint32 DeltaX = abs(x2 - x1);
    uint32* Start = (x1 < x2) ? ((uint32*)Buffer->Memory) + Buffer->Width * Y + x1 :((uint32*)Buffer->Memory) +  Buffer->Width * Y + x2;
    memset(Start, 0x00ff0000, DeltaX * sizeof(uint32));
    
}

void Win32ResizeDIBSection(Bitmap * Buffer, int32 Width, int32 Height){
    if(Buffer->Memory){
        VirtualFree(Buffer->Memory, 0, MEM_RELEASE);
    }

    const uint32 SizeMod = 10;
    Buffer->Height = 256;
    Buffer->Width = 256;

    Buffer->Info.bmiHeader.biHeight = -Buffer->Height;
    Buffer->Info.bmiHeader.biWidth = Buffer->Width;
    int BitmapSize = Buffer->Width * Buffer->Height * 4;
    Buffer->Memory = VirtualAlloc(0, BitmapSize, MEM_COMMIT, PAGE_READWRITE); 
    memset(Buffer->Memory, 0x00ff000, BitmapSize); 
    
} 

void Win32DisplayBuffer(Bitmap* Buffer, HDC DeviceContext,int Width, int Height){
    StretchDIBits(DeviceContext,
                  0, 0, Width, Height,
                  0, 0, Buffer->Width, Buffer->Height,
                  Buffer->Memory,
                  &Buffer->Info,
                  DIB_RGB_COLORS,
                  SRCCOPY);
}

LRESULT CALLBACK WindowCallback(HWND Window, UINT Message, WPARAM WParam, LPARAM LParam )
{
    LRESULT Result = 0;
    switch(Message)
    {

        case WM_DESTROY: 
        {
            PostQuitMessage(0);
            running = false;
        }break;
        
        case WM_QUIT: 
        {
            OutputDebugStringA("QUIT"); 
            DestroyWindow(Window);
        }break;
        
        case WM_ACTIVATEAPP: 
        {
            OutputDebugStringA("FOCUSE"); 
        }break;
        
        case WM_CREATE: 
        {
            OutputDebugStringA("CREATED"); 
        }break;
        
        case WM_MOVE: 
        {
            OutputDebugStringA("MOVE"); 
        }break;
        
        case WM_SIZE: 
        {
            OutputDebugStringA("SIZE"); 
            int Width = LOWORD(LParam);   
            int Height = HIWORD(LParam);
            Win32ResizeDIBSection(&Backbuffer, Width, Height);

        }break;
        
        default:
        {
           Result = DefWindowProc(Window, Message, WParam, LParam);    
        }break;
    }
    return Result;
}


int CALLBACK WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, PSTR cmdline, int32 cmdshow)
{
    WNDCLASSEXA WindowClass = {};
    WindowClass.cbSize = sizeof(WNDCLASSEXA);
    WindowClass.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW;
    WindowClass.lpfnWndProc = WindowCallback; //TODO 
    WindowClass.hInstance = hInst;
    WindowClass.hIcon = 0;
    WindowClass.lpszClassName = "Window Class";
    

    Backbuffer.Info.bmiHeader.biSize = sizeof(Backbuffer.Info.bmiHeader);
    Backbuffer.Info.bmiHeader.biPlanes = 1;
    Backbuffer.Info.bmiHeader.biBitCount = 32;
    Backbuffer.Info.bmiHeader.biCompression = BI_RGB;
    
    if(!RegisterClassExA(&WindowClass)){
        DebugBreak();
    }

    HWND WindowHandle = CreateWindowEx(0, WindowClass.lpszClassName, "DEngine", WS_TILEDWINDOW | WS_VISIBLE,
                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, hInst, 0);
    
    if(!WindowHandle){
        running = false;
        DebugBreak();
    }
    
    MSG message;
    int xoffset = 0;
    while(running){
        
        while(PeekMessage(&message, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }


                   
        if (Backbuffer.Height > 0 && Backbuffer.Width > 0) {
            FOR_RANGE(y, Backbuffer.Height) {
                FOR_RANGE(x, Backbuffer.Width) {
                    SetPixel(&Backbuffer,x, y, 0xff / Backbuffer.Width * x ,0, y);
                }
            }
        }


        HDC DeviceContext = GetDC(WindowHandle);
        ivec2 WindowSize = GetWindowSize(WindowHandle);
        xoffset++;
        DrawHLine(&Backbuffer, 65, 23, 230)
        DrawLine(&Backbuffer, 32, 32, Backbuffer.Width - 1 -32, 96);
        DrawVLine(&Backbuffer, 32, 32, 96);
        DrawLine(&Backbuffer, 32, 32 + 64, Backbuffer.Width - 1 -32, 96 + 64);
        DrawLine(&Backbuffer, Backbuffer.Width - 1 -32, 96, Backbuffer.Width - 1 -32, 96 + 64);
        Win32DisplayBuffer(&Backbuffer, DeviceContext, WindowSize.Width, WindowSize.Height);
        ReleaseDC(WindowHandle, DeviceContext);
    }

    DestroyWindow(WindowHandle);
    
    return 0;
} 
